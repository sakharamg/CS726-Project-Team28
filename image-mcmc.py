import os
import cv2
import click
import numpy as np
from tqdm import tqdm
from skimage.draw import line as skline


def read_image(filename):
    '''
    Reads in an image whose location is given by filename, and returns
    a RGB image. If the imported image has an alpha channel, this is
    blended as if there were a white canvas underneath in order to give
    a RGB image.

    :param str filename: File location of the image to load.
    :return: The image in RGB format, as a numpy array with ndims = 3 and
        shape (height, weight, channels=3).
    :rtype: ndarray
    '''
    # Import in the image
    img = cv2.imread(filename, cv2.IMREAD_UNCHANGED)

    # Handle transparency
    if (img.shape[2] == 4):
        img_rgb = img[:, :, :3]
        img_alpha = img[:, :, 3]

        alpha = img_alpha[:, :, np.newaxis].astype(np.float32) / 255.0
        alpha = np.concatenate((alpha, alpha, alpha), axis=2)

        img = img_rgb.astype(np.float32)*alpha + \
            np.ones_like(img_rgb)*255*(1-alpha)
        img = img.astype(np.uint8)

    return img


def metropolis_hastings(stat_dist, ini_point, it_num, bandwidth):
    '''
    Given an input distribution, a RW Metropolis Hastings algorithm
    is run on the distribution.

    :param ndarray stat_dist: 2D numpy array with values in [0, 1],
        corresponding to an supposed discrete density function (up to
        a normalizing constant).
    :param tuple ini_point: Initial location for the MCMC algorithm to
        begin at.
    :param int it_num: Number of iterations to run the algorithm for.
    :param float_or_ndarray bandwidth: Positive float or array of floats
        gives the standard deviation (either constant or spatially) for
        the Gaussian kernel used as the proposal density.
    :return: Returns a list of tuples of pixel locations, corresponding
        to samples generated by the Metropolis Hastings algorithm.
    :rtype: list
    '''

    # Preallocation and obtaining useful information from the input args
    it_list = [None]*(it_num + 1)
    img_dims = stat_dist.shape
    ylim, xlim = img_dims
    it_list[0] = ini_point

    def gen_new_pixel(loc, scale):
        '''
        Generates a sample from a Normal distribution with mean loc and
        standard deviation scale (isotropically) constrained to lie within
        the bounds of the image.
        '''
        return_count = 1

        while return_count:
            new_pixel = tuple(int(round(i))
                              for i in np.random.normal(loc, scale))
            if (0 <= new_pixel[0] < ylim) & (0 <= new_pixel[1] < xlim):
                return_count = 0

        return new_pixel

    # Generate samples from stat_dist in terms of pixel locations
    if isinstance(bandwidth, (list, tuple, np.ndarray)):
        for i in tqdm(range(it_num), desc='Sampling'):
            # Sample new pixel, calculate acceptance probability
            new_pixel = gen_new_pixel(it_list[i], bandwidth[it_list[i]])
            ratio_1 = stat_dist[new_pixel]/stat_dist[it_list[i]]
            band_ratio = (bandwidth[it_list[i]]/bandwidth[new_pixel])
            euc_dist = np.linalg.norm(
                np.array(new_pixel) - np.array(it_list[i]))
            band_diff = (1/bandwidth[it_list[i]])**2 - \
                (1/bandwidth[new_pixel])**2
            ratio_2 = band_ratio*np.exp(0.5*euc_dist*band_diff)
            accept_prob = min(1, ratio_1*ratio_2)

            # Decide whether to accept or reject the new pixel location
            if (np.random.random() < accept_prob):
                it_list[i+1] = new_pixel
            else:
                it_list[i+1] = it_list[i]
    else:
        for i in tqdm(range(it_num), desc='Sampling'):
            # Sample new pixel, calculate acceptance probability
            new_pixel = gen_new_pixel(it_list[i], bandwidth)
            accept_prob = min(1, stat_dist[new_pixel]/stat_dist[it_list[i]])

            # Decide whether to accept or reject the new pixel location
            if (np.random.random() < accept_prob):
                it_list[i+1] = new_pixel
            else:
                it_list[i+1] = it_list[i]

    return it_list


def sample_ini_point(dist):
    '''
    Gives a point with positive density to begin sampling from.
    '''
    image_dims = dist.shape
    ylim, xlim = image_dims
    ini_point = tuple([int(round(x/2)) for x in image_dims])

    while (dist[ini_point] == 0):
        ini_point = np.random.normal(ini_point, 5)
        ini_point = np.clip(ini_point, 0, [xlim, ylim])
        ini_point = tuple([int(round(i)) for i in ini_point])

    return ini_point


@click.command()
@click.option(
    '--fname',
    required=True,
    type=click.Path(exists=True),
    help='Location of image to perform the image transformation on.'
)
@click.option(
    '--export_fname',
    default=None,
    help='Allows for a custom export filename/directory to be specified.'
)
@click.option(
    '--it_num',
    type=click.IntRange(min=1),
    default=40000,
    help=('Specified the number of iterations to perform the Metropolis'
          ' Hastings sampling algorithm. Defaults to 40000.')
)
@click.option(
    '--band',
    type=click.FloatRange(min=1),
    default=30,
    help=('Standard deviation for the Gaussian proposal density used'
          ' for the MH algorithm. Must be positive and greater than 1.'
          ' Defaults to 30.')
)
@click.option(
    '--point_radius',
    type=click.IntRange(min=1),
    default=4,
    help=('Specifies the sizes of points plotted. Must be a integer'
          ' greater than one. Defaults to 4.')
)
@click.option(
    '--line_width',
    type=click.IntRange(min=1),
    default=1,
    help=('Specifies the width of lines plotted. Must be an integer'
          ' greater than one. Defaults to 1. NOTE: Currently only'
          ' works when the blend mode is not active.')
)
@click.option(
    '--blend',
    is_flag=True,
    help=('Triggers to draw lines with a color gradient. Note that this'
          ' will substantially increase rendering time.')
)
@click.option(
    '--band_mask',
    type=click.Path(exists=True),
    default=None,
    help=('Location of greyscale image which defines a gradient of the'
          ' choice of standard deviation to be used by the proposal by'
          ' location. Darker areas correspond to smaller standard deviations'
          ' as prescribed by the inputs to band_minmax.')
)
@click.option(
    '--band_minmax',
    nargs=2,
    type=click.IntRange(min=1),
    help=('Specifies the minimum (1st arg) and maximum standard deviation to'
          ' be used for the proposal distribution for the Metropolis'
          ' Hasting algorithm. This only does something if the band_mask'
          ' variable exists.')
)
def render_image(fname,
                 export_fname,
                 it_num,
                 band,
                 point_radius,
                 line_width,
                 blend,
                 band_mask,
                 band_minmax):
    '''
    Renders a 'MCMC'-ified version of an input image whose location
    is given by FNAME.
    '''
    # Load image, extract lightness channel and use this to form
    # a 'density' to use for sampling
    img = read_image(fname)
    img_lab = cv2.cvtColor(img, cv2.COLOR_BGR2Lab)
    stat_dist = 1 - img_lab[:, :, 0]/255
    image_dims = stat_dist.shape
    ini_point = sample_ini_point(stat_dist)

    # Create custom export filename if it doesn't exist already
    if export_fname is None:
        export_fname = (os.path.splitext(fname)[0] + '_mcmc' +
                        os.path.splitext(fname)[1])

    # Handle custom bandwidth scheme if specified
    if band_mask is not None:
        # Set bandwidth to a 2D array of ints corresponding to the dimensions
        # of the original image
        band_img = read_image(band_mask)
        band_img = cv2.cvtColor(band_img, cv2.COLOR_BGR2GRAY)/255
        bandwidth = band_minmax[0] + band_img * \
            (band_minmax[1] - band_minmax[0])
    else:
        # Set bandwidth to an integer
        bandwidth = band

    # Obtain sampled pixels
    it_list = metropolis_hastings(stat_dist, ini_point, it_num, bandwidth)

    # Render image
    new_img = 255*np.ones((image_dims[1], image_dims[0], 3), np.uint8)

    if blend:
        for i in tqdm(range(it_num), desc='Rendering'):
            # Grab colors of start and end pixels
            start_color = img[it_list[i][0], it_list[i][1], :]
            end_color = img[it_list[i+1][0], it_list[i+1][1], :]

            # Render dots and lines to canvas
            new_img = cv2.circle(new_img, it_list[i],
                                 radius=point_radius,
                                 color=tuple([int(x) for x in start_color]),
                                 thickness=-1)

            new_line = list(zip(*skline(*it_list[i], *it_list[i+1])))
            blender = np.linspace(0, 1, len(new_line))

            start_color = np.array(start_color)
            end_color = np.array(end_color)
            color_mix = start_color[:, np.newaxis] * \
                (1-blender) + end_color[:, np.newaxis]*blender
            color_mix = color_mix.astype(np.uint8).transpose()

            for j in range(len(new_line)):
                new_img[new_line[j][::-1]] = color_mix[j]
    else:
        for i in tqdm(range(it_num), desc='Rendering'):
            # Grab color of starting pixel
            img_color = img[it_list[i][0], it_list[i][1], :]
            img_color = tuple([int(x) for x in img_color])

            # Render dots and lines to canvas
            new_img = cv2.circle(new_img, it_list[i],
                                 radius=point_radius,
                                 color=img_color,
                                 thickness=-1)
            new_img = cv2.line(new_img, it_list[i], it_list[i+1],
                               img_color, line_width)

    # Export image
    print(new_img.shape)
    new_img = np.swapaxes(new_img[:, :, :], 0, 1)
    print(new_img.shape)
    if not cv2.imwrite(export_fname, new_img):
        raise Exception("Could not write image.")
    else:
        print('Successfully wrote image to disk.')


if __name__ == '__main__':
    render_image()

#  Copyright 2022 Andrew Davison

#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at

#      http://www.apache.org/licenses/LICENSE-2.0

#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.